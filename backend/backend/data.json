{
  "timestamp": "20251031_035522",
  "query": "why is conhesion used in method design",
  "summary": "1. Clear intent: A method should have a clear intent, which is the purpose of the method.\n2. Pre and post conditions: The method should have pre and post conditions that ensure the method is working correctly.\n3. Cohesion: A method should be cohesive, meaning it should have tightly related and dependent parts.\n4. Loosely coupled: A method should be loosely coupled, meaning it should not depend on external information or knowledge.\n5. Reusable: A method should be reusable, meaning it can be used multiple times without having to re-write the code.\n6. Unit-testable: A method should be unit-testable, meaning it can be tested independently of the rest of the code.\n7. Cohesion: A method should be cohesive, meaning it should have tightly related and dependent parts.\n8. Loosely coupled: A method should be loosely coupled, meaning it should not depend on external information or knowledge.\n9. Reusable: A method should be reusable, meaning it can be used multiple times without having to re-write the code.\n10. Unit-testable\n1. Clear intent: A method should be easy to understand and communicate its purpose. 2. Precise pre and post conditions: The method should have clear and specific pre and post conditions that ensure the method is working as intended. 3. Cohesive: The method should be cohesive, meaning that it is tightly related to other methods in the same class or package. 4. Loosely coupled: The method should be loosely coupled, meaning that it does not depend on external information or knowledge. 5. Reusable: The method should be reusable, meaning that it can be used in multiple places without requiring modification. 6. Unit-testable: The method should be unit-testable, meaning that it can be tested independently of other methods. 7. Cohesion: The method should have tightly related dependencies, meaning that the method is dependent on only a few external resources. 8. Coupling: The method should have few dependencies, meaning that it is not dependent on external resources that are not necessary for its functionality. 9. Reusability: The method should be reusable, meaning that it can be used in multiple places without requiring modification. 1\n1. Summarize the context information and the key points of the given material.\n2. Summarize the chunk content in a clear and concise manner.\n3. Use bullet points or numbered lists to organize the paragraphs.\n4. Use headings or numbered lists to highlight important points.\n5. Use subheadings or bullet points to break up the paragraphs into smaller sections.\n6. Use bold or italic text to emphasize important points.\n7. Use quotes or paraphrasing to provide additional context or explanation.\n8. Use diagrams or images to illustrate key points.\n9. Use subheadings or bullet points to organize the paragraphs.\n10. Use headings or numbered lists to highlight important points.\n11. Use subheadings or bullet points to break up the paragraphs into smaller sections.\n12. Use bold or italic text to emphasize important points.\n13. Use quotes or paraphrasing to provide additional context or explanation.\n14. Use diagrams or images to illustrate key points.\n15. Use subheadings or bullet points to organize the paragraphs.\n16.\n1. Clear intent: A method should be easy to understand, reuse, and maintain.\n2. Precise pre and post conditions: A method should have clear pre and post conditions that define its behavior.\n3. Cohesive: A method should be cohesive, meaning that it has a tight relationship with its inputs and outputs.\n4. Loosely coupled: A method should be loosely coupled, meaning that it does not depend on external information or knowledge.\n5. Reusable: A method should be reusable, meaning that it can be used multiple times without requiring significant changes.\n6. Unit-testable: A method should be unit-testable, meaning that it can be tested independently of its dependencies.\n7. Cohesion: A method should have a clear intent, precise pre and post conditions, cohesive, loosely coupled, and reusable.\n8. Coupling: A method should have tightly-related dependencies, meaning that it is dependent on external information or knowledge.\n9. Dependencies: A method should have dependencies on other methods, but not on the environment or other external resources.\n10. Maintenance: A method\n1. Functional decomposition:\n- Decompose a system/task into smaller systems/tasks, which are further decomposed into even smaller system/task units.\n- Objects are the building blocks of the system/task.\n- Ask: \"What can this object do?\" (not what attributes we need for this object)\n- Advantages:\n- Better readability if detail is abstracted away\n- Thinking at a higher and more abstract level\n- More reusability of code (by eliminating code duplication)\n- Changes to be isolated\n- Self-designed methods\n2. Methods:\n- Action oriented, so should objects – ask: \"what can this object do?\" (not what attributes we need for this object)\n3. Modularity, cohesion, coupling, instance methods design, tradeoffs:\n- Design of Methods:\n- Ignore headings or numbered\n1. Ignore headings or numbered lists. Focus only on meaningful explanations.\n2. Summarize the chunk content into clear, concise paragraphs suitable for studying.\n3. Focus on meaningful explanations.\n4. Focus on the chunk content.\n5. Focus on the meaningful explanations.\n6. Focus on the chunk content.\n7. Focus on the meaningful explanations.\n8. Focus on the chunk content.\n9. Focus on the meaningful explanations.\n10. Focus on the chunk content.\n11. Focus on the meaningful explanations.\n12. Focus on the chunk content.\n13. Focus on the meaningful explanations.\n14. Focus on the chunk content.\n15. Focus on the meaningful explanations.\n16. Focus on the chunk content.\n17. Focus on the meaningful explanations.\n18. Focus on the chunk content.\n19. Focus on the meaningful explanations.\n20. Focus on the chunk content.\n21. Focus on\n1. Good Methods Start with Variable Names: Intention-revealing method names\n2. Typically, method names are verbs or verb phrases, such as sort, print, getSize, getList.\n3. Sometimes, method names can be nouns if they refer to properties of an object, like size, length, firstElmtor.\n4. Sound like questions like isVisible, isOnTimeif Boolean values are returned.\n5. Same criteria apply to variable names:\n- nTis too short for “number of threads”\n- numberOfThreadsInThisProgramis too long\n- numberOfThreads\n6. numberOfThreadsor even numThreadsis acceptable\n7. What if you don’t seem to figure out a good name easily?\n8. Is the method doing too much?\n9. Is the method just a product of ad-hoc practices?\n10. Summarize the following chunk into clear, concise paragraphs suitable for studying.\n11. Ignore headings or numbered lists. Focus only on meaningful explanations.\n1. Good Methods Start with Variable Names\n2. Intention-revealing method names\n3. Typically, method names are verbs or verb phrases, such as sort printStudentRecord,  or getSize, getList.\n4. Sometimes, method names can be nouns if they refer to properties of an object, like: size, length, firstElmtor\n5. Sounds like questions like isVisible, isOnTimeif Boolean values are returned.\n6. Same criteria apply to variable names:\n7. nTis too short for “number of threads”\n8. numberOfThreadsInThisProgramis too long\n9. numberOfThreads\n10. numberOfThreads\n11. What if you don’t seem to figure out a good name easily?\n12. Is the method doing too much?\n13. Is the method just a product of ad-hoc practices?\n14. Good Methods Start with Variable Names\n15. Intention-revealing method names\n16. Typically, method names are verbs or verb phrases, such as sort printStudentRecord,  or getSize, getList\n1. Level 1: Simple, isolated, and independent.\n2. Level 2: Related, but not tightly coupled.\n3. Level 3: Tightly coupled, but not overly complex.\n4. Level 4: Complex, but not overly coupled.\n5. Level 5: Complex, tightly coupled, and difficult to maintain.\nCohesion – degree of interaction within a method\n1. Does the method do one thing or multiple things?\n2. If the method does multiple things, how tightly are they related?\nCoupling – degree of dependency on external info/knowledge/capability\n1. Two methods that interact with each other are tightly coupled.\n2. Two methods that do not interact with each other are loosely coupled.\nReuse and maintainability\n1. Clear intent\n2. Precise pre and post conditions\n3. Cohesive\n4. Loosely coupled\n5. Reusable\nUnit-testable\n1. Coincidental\n- Multiple actions performed\n- Unrelated\n- Not likely reusable\n- Not maintainable\n- Unpredictable impact\n- Break into separate methods\n- Integrate the pieces into other methods\n- Avoid in the first place\n2. Logical Cohesion\n- Performance of multiple actions\n- Unrelated actions\n3. A method has logical cohesion when it performs a series of actions, but only one is selected at a time by the calling module (conditionals are present).\n- Clear intent\n- Precise pre and post conditions\n- Cohesive\n- Loosely coupled\n- Reusable\n- Unit-testable\n- Cohesion - degree of interaction within a method\n- Does the method do one thing or multiple things?\n- If the method does multiple things, how tightly are they related?\n- Coupling - degree of dependency on external info/knowledge/capability\n- Two methods with different pre and\n1. Conditional statements:\n- runApp(userCmd) - checks if the user has entered a valid command and calls the appropriate method based on the command.\n- draw(shapeName) - draws the specified shape using the appropriate method based on the shape name.\n- calculate(algorithm, input) - calculates the specified algorithm using the appropriate method based on the input.\n- Issues:\n- Little clarity on what method does exactly - this is a design decision.\n- Tightly coupled with contextual code - this is a design decision.\n- Reusability is low - this is a design decision.\n- Factory methods are of this kind, but we have less concerns because of the predictability of such methods.\n2. Contextual code:\n- draw(shapeName) - calls the appropriate method based on the shape name.\n- calculate(algorithm, input) - calls the appropriate method based on the input.\n- Lack of clarity on what method does exactly - this is a design decision.\n- Reusability is low - this is a design"
}