{
    "timestamp": "20251023_052604",
    "query": "Why is method design important for coding",
    "summary": "1. Modularity:\n- A method is modular if it performs a series of actions related in time.\n- A method is modular if it performs a series of actions related by a procedure/algorithm to be followed by the product.\n2. Cohesion:\n- A method is cohesive if it performs a series of actions related in time.\n- A method is cohesive if it performs a series of actions related by a procedure/algorithm to be followed by the product.\n3. Coupling:\n- A method is coupled if it performs a series of actions related in time.\n- A method is coupled if it performs a series of actions related by a procedure/algorithm to be followed by the product.\n4. Instance Method Design:\n- A method is\n1. Coincidental 2. Logical Cohesion\nA method has coincidental cohesion if it performs multiple, unrelated actions. Issues: Breaking it into separate methods, integrating the pieces into other methods, or avoiding in the first place. 2. Logical Cohesion\nA method has logical cohesion when it performs a series of actions, but only one is selected at a time by the calling module (conditionals are present). Issues: Tightly coupled with contextual code (do I call the method at the right place using correct arguments? – less freedom for code modifiability), Reusability is low.\n1. Functional Decomposition:\na. Decompose a system/task into smaller systems/tasks, which are further decomposed into even smaller system/task units.\nb. Objects are action oriented, so should have methods.\nc. Advantages of functional decomposition to allow:\n- Better readability if detail is abstracted away\n- Thinking at a higher and more abstract level\n- Reusability of code (by eliminating code duplication)\n- Changes to be isolated\n- Self-documentation\n- Public static double nthRoot(double value, int n)\n- Public static Set intersect(Set s1, Set s2)\n- Public static int[ ] Sort(int[ ] array, Comparator comp)\n- Functional decomposition also provides opportunities for discovering polymorphic functional units when tasks become parallel or scenario-dependent, or branching out\n2. Methods are action oriented, so should objects – ask: \"what can this object do?\" (not what attributes we need for this object)\na. Advantages of functional decomposition to allow:\n1. Good Methods Start with Variable Names: Intention-revealing method names:\nVerbs or verb phrases, such as \"sort\", \"print\", \"getSize\", \"getList\".\nSometimes, method names can be nouns if they refer to properties of an object, like \"size\", \"length\", \"firstElmtor\".\nSometimes, method names can be questions like \"isVisible\", \"isOnTime\", \"isNumberOfThreads\".\nSame criteria apply to variable names:\n- nTis too short for \"number of threads\"\n- numberOfThreadsInThisProgramis too long\n- numberOfThreadsor even numThreadsis acceptable\nWhat if you don't seem to figure out a good name easily?\nIs the method doing too much?\nIs the method just a product of ad-hoc practices?\n2. Functional Decomposition: Decompose a system/task into smaller systems/tasks, which are further decomposed into even smaller system/task units.\nMethods are action oriented, so should objects – ask: \"what can this object do?\" (not what attributes we need for this object)\nAdv\n1. Temporal Cohesion   2. Procedural Cohesion A method is of temporal cohesion when it performs a series of actions related in timeExampleopen various files, initialize data structures, read initial data (init() for card games)What we typically do in a constructor.IssuesActions of the module are weakly related to one another.  Unlikely to be reused\n3. Temporal Cohesion   4. Procedural Cohesion A method is of temporal cohesion when it performs a series of actions related in timeExampleopen various files, initialize data structures, read initial data (init() for card games)What we typically do in a constructor.IssuesActions of the module are weakly related to one another.  Unlikely to be reused\n5. Temporal Cohesion   6. Procedural Cohesion A method is of temporal cohesion when it performs a series of\n1. Coincidental: A method has coincidental cohesion if it performs multiple, unrelated actions.\n2. Logical Cohesion: A method has logical cohesion when it performs a series of actions, but only one is selected at a time by the calling module (conditionals are present).\n3. Procedural Cohesion: A method is of procedural cohesion when it performs a series of actions related in time.\n4. Temporal Cohesion: A method is of temporal cohesion when it performs a series of actions related by a procedure/algorithm to be followed by the product (we often write such methods to provide logical clarity).\nIssues:\n1. Coincidental: Not likely reusable, not maintainable, unpredictable impact going forward, easy to address, break it into separate methods, integrate the pieces into other methods, or avoid in the first place.\n2. Logical Cohesion: Bad for unit tests, easy to address, break it into separate methods, integrate the pieces into other methods, or avoid in the first place.\n3. Procedural Cohesion: Unlikely\n1. Coincidental 2. Logical Cohesion A method has coincidental cohesion if it performs multiple, unrelated actions Issues not likely reusable, not maintainable Unpredictable impact going forward Bad for unit tests Easy to address Break it into separate methods, integrate the pieces into other methods, or avoid in the first place Logical cohesion A method has logical cohesion when it performs a series of actions, but only one is selected at a time by the calling module Issues Little clarity on what method does exactly Tightly coupled with contextual code Do I call the method at the right place using correct arguments? – less freedom for code modifiability Reusability is low Factory methods are of this kind, but we have less concerns because of the predictability of such methods.\n1. Communicational Cohesion\nModule performs a series of actions related by a procedure/algorithm to be followed in a process, but in addition, all the actions operate on the same data. Examples:\n- updateAuditTrail: update record in database and write itto audit trail\n- getCurrentCoordinates: calculate new coordinates and send themto terminal\nBenefit:\n- More likely to be reused\n- Easy to understand\n- Better stability\n2. Temporal Cohesion\nA method is of temporal cohesion when it performs a series of actions related in time. Examples:\n- open various files, initialize data structures, read initial data (init() for card games)\nWhat we typically do in a constructor.\n- Actions of the module are weakly related to one another\n- Unlikely to be reused\n- Issues:\n3. Procedural Cohesion\nA method is of procedural cohesion if it performs a series of actions related by a procedure/algorithm to be\n1. Informational/Sequential Cohesion\nA module has informational/sequential cohesion if it performs several actions, each with its own entry point with independent code, and all actions use the result of another action, making them unbreakable. The module is easy to understand and maintain, and it can be reused.\n2. Calculate trajectory and Predict target\nThis method is already in good cohesion, but we might ask whether further decomposition along the dash line still makes good sense. Trajectory calculation is useful in other situations, and target prediction can be done with trajectory being calculated in other ways.\n3. Communicational Cohesion\nA module performs a series of actions related by a procedure/algorithm to be followed in a process, but in addition, all the actions operate on the same data. Examples include updating record in database and writing it to audit trail, and calculating new coordinates and sending them to terminal. The module is easy to understand and can be reused.\n4. Informational/Sequential Cohesion\nA module has informational/sequential cohesion if it performs several actions, each with its own entry point with independent\n1. Temporal Cohesion\n- A method is of temporal cohesion when it performs a series of actions related in time\n- Example: open various files, initialize data structures, read initial data (init() for card games)\n- What we typically do in a constructor\n- Procedural cohesion\n- Example: read part number and update repair record on master file\n- Read database records and update labels\n- Create panel, set panel layout, set border, add buttons, add listeners\n- Reusability is likely low\n2. Functional Cohesion\n- Module with functional cohesion performs exactly one well-defined action, although there may be many statements\n- Examples:\n- get temperature of furnace\n- calculate sales commission\n- All data structures’ service methods\n- Instance methods are often of this sort of cohesion… many simply change objects’ states: stu.addClass(classCode), enrollment.removeWaitList(classCode), …\n- Caution: enrollment.getWaitlist()\n1. Method Coupling\n- Fact: Less cohesive methods tend to be more tightly coupled with their calling methods.\n- Coincidental cohesion (ad-hoc cohesion) - Cohesion is weakened when the method is not cohesive.\n- Logic cohesion - Caller controls where to call and what argument to pass.\n- Communication cohesion - Data in (arguments) and data out (what method returns); method can be treated as a black-box (data coupling).\n- Two coupling situations through data sharing\n- Share external data (common coupling), which is more consequential than sharing instance data (sharing instance data is expected, but invariants should be enforced in instance methods).\n- Passing more data than needed (often due to convenience) creates coupling (stamp coupling) that can be easily avoided.\n2. URL link: https://www.youtube.com/watch?v=Df0WVO-c3Sw&t=54s\n- Summarize the URL link to a video on YouTube.\nCohesion/Coupling Examples Logic cohesion/control couplingvoid doThisOrDoThat(booleanflag){if ( flag ){ …twenty lines of code to do this…}else {…twenty lines of code to do that… } }Better? void doThisOrDoThat(boolean flag){if ( flag ) doThis();  else …twenty lines of code to do that… }Better?   void doThisOrDoThat(booleanflag){if ( flag ) doThis();  else doThat()  } More analysis needed ….\nGood methods potentially:displayTimeOfArrival (flightNumber);computeGrossPay (hoursWorked, payRate);jobQueue.getJobWithHighestPriority();Danger of method side effect! Common coupling effect…int x = 10;int  getVal(int a){ return a + x++; }This “apparent” equality becomes false!getVal(3) == getVal(3) ?methodX(){… boolean isOk = processData(dataInfo, “update”); … if(\n1. Design Inclusion, Exclusion, and Tradeoffs\n- Specificity vs. Generality:\n- Designing methods that are specific to the needs of the application, while also being general enough to allow for all possible implementations. - Seeking tradeoffs:\n- Optimizing readability and readability for the purpose of the application, while also ensuring that the method is efficient and effective. 2. Pre/Post Conditions\n- Must serve the needs for specificity and generality\n- Seeking tradeoffs:\n- Optimizing readability and readability for the purpose of the application, while also ensuring that the method is efficient and effective. 3. Specificity vs. Generality\n- Pre/post conditions must serve the needs for specificity and generality\n- Optimizing readability and readability for the purpose of the application, while also ensuring that the method is efficient and effective. 4. Specificity vs. Generality\n- Optimizing readability and readability for the purpose of the application, while also\nA method has coincidental cohesion if it performs multiple, unrelated actions.\n2. Logical Cohesion\nA method has logical cohesion when it performs a series of actions, but only one is selected at a time by the calling module.\n3. Coincidental Cohesion\nA method has coincidental cohesion when it performs multiple, unrelated actions.\n4. Logical Cohesion\n5. Coincidental Cohesion\n6. Logical Cohesion\n7. Coincidental Cohesion\n8. Logical Cohesion\n1. Case Study –Override:  equals(Object)Java API states:  “The equalsmethod implements an equivalence relation:It’s reflexive: for any x, x.equals(x)returns true.It’s symmetric:for any xand y, if x.equals(y)returns true, so does y.equals(x).It’s transitive:   for any x, y, and z, if x.equals(y)andy.equals(z)are both true, so is x.equals(z).\n2. Consider the Triangle class – two triangles are equal if their vertices are equal\n3. public boolean equals(Object obj) {if( obj == null ) return false;if( obj == this ) return true; if(obj.getClass() !=  this.getClass()) return false;if(!super.equals(obj)) return false;   ColoredTriangle otherT riangle = (ColoredTriangle) obj;return      this.color.equals(otherTriangle.color);  }\n4. Behavior of “equals” in supperclass\n1. Code Refactoring: Refactoring is a process of modifying working code to make it more readable, sustainable, or elegant without changing its external behavior.\n2. Most high-end IDEs have built-in support for refactoring.\n3. Refactoring Activities:\n- Rename a method or a variable\n- Introduce new types/interface when opportunities for polymorphism identified\n- Replace a variable with a query method\n- Extract methods into a superclass\n- Delegation of responsibilities\n- Change of visibility (of variables or methods)\n- Code refactoring can't rescue a poor design, and it can't help with structural alteration.\n4. Functional Decomposition: Decompose a system/task into smaller systems/tasks, which are further decomposed into even smaller system/task units.\n5. Methods are action oriented, so should objects – ask: \"what can this object do?\" (not what attributes we need for this object)\n6. Advantages of functional decomposition to allow:\n- better readability if detail is abstracted away\n- thinking at a higher"
}